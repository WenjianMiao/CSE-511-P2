This is the 1st Part of Project 2.

To run our code, you need to first use "make clean; make", and then open the hello_world_client.c file, you need to set the nodes information for our distributed lock system. Namely, set num_nodes to be the real number of nodes in the system; set nodes[0], nodes[1], ... nodes[num_nodes-1] to be the real IP Address of each nodes. Finally, first run "./server" in every node, and then run "./client #node_number" in each node. For example. run "./client 0", "./client 1", in node 1 and node 2.

To test our code, you can freely set the sequences or the types of operations in the hello_world_client.c, namely, psu_acquire_lock, psu_release_lock in different clients. 


Idea of this part of Project 2:

In the init_lock_mgr, we just need to get the nodes information. In the psu_aquire_lock, the client first called local server to get its Our_Sequence_Number. And then client create multithread to send request to each remote server, and then wait for the responses from all of the remote server(use thread_join), then get the lock. When the server receives request, it determine if it need to reply now. If yes, the server reply to the client. Otherwise, the server wait until its local client release the lock, and then send the reply to the node. In the psu_release_lock, the client just need to call the local server to set some state, and change the value of Reply_Deferred so that the server can reply to some nodes which wait for the response of this server.

The server is also multithreaded. That means in each request, the server will create a thread to deal with that. We need to change code in msg_svc.c automatically generated by "rpcgen -M". You can see the details in the code.



Author:  Wenjian Miao  &&  Yilei Lin
